#' Control function to define the processor for terms in the formula
#' 
#' @param form the formula to be processed
#' @param data the data for the terms in the formula
#' @param controls controls for gam terms
#' @param output_dim the output dimension of the response
#' @param specials_to_oz specials that should be automatically checked for 
#' @param automatic_oz_check logical; whether to automatically check for DNNs to be orthogonalized
#' @param identify_intercept logical; whether to make the intercept automatically identifiable
#' @param param_nr integer; identifier for the distribution parameter
#' @param ... further processors
#' @return returns a processor function
#' 
#' 
process_terms <- function(
  form, data, controls, 
  output_dim, param_nr, 
  specials_to_oz = c(), 
  automatic_oz_check = TRUE, 
  identify_intercept = FALSE,
  ...){
  
  defaults <- 
    list(s = gam_processor,
         te = gam_processor,
         ti = gam_processor,
         int = int_processor,
         lin = lin_processor,
         lasso = l1_processor,
         ridge = l2_processor,
         offsetx = offset_processor,
         rwt = rwt_processor
    )
  
  dots <- list(...)
  
  if(length(dots)>0 && is.null(names(dots)))
    stop("Please provide named arguments.")
  
  procs <- c(defaults, dots)
  specials <- names(procs)
  specials <- specials[sapply(specials, nchar)>0]
  
  # otherwise offset is dropped
  form <- rename_offset(form)
  
  # for row-wise tensor product
  form <- rename_rwt(form)
  
  list_terms <- separate_define_relation(form = form, 
                                         specials = specials, 
                                         specials_to_oz = specials_to_oz, 
                                         automatic_oz_check = automatic_oz_check)
  
  if("1" %in% sapply(list_terms, "[[", "term"))
  {
    list_terms[[which(sapply(list_terms, "[[", "term")=="1")]]$term <- 
      "(Intercept)"
  }
  
  args <- list(data = data, output_dim = output_dim, param_nr = param_nr)
  result <- list()
  
  # add intercept terms
  if(attr(terms.formula(form), "intercept") & !"(Intercept)" %in% 
     sapply(list_terms, "[[", "term"))
    list_terms[[length(list_terms)+1]] <- 
    list(term = "(Intercept)",
         nr = length(list_terms)+1,
         left_from_oz = TRUE,
         right_from_oz = NULL)
  
  for(i in 1:length(list_terms)){
    
    lin_counter <- 1
    args$term = list_terms[[i]]$term
    spec <- get_special(list_terms[[i]]$term, specials = specials)
    args$controls <- controls 
    args$controls$procs <- procs
    if(is.null(spec)){
      if(args$term=="(Intercept)")
        result[[i]] <- c(list_terms[[i]], do.call(int_processor, args)) else
          result[[i]] <- c(list_terms[[i]], do.call(lin_processor, args))
        lin_counter <- lin_counter+1
    }else{
      result[[i]] <- c(list_terms[[i]], do.call(procs[[spec]], args))
    }
    
  }
  
  return(result)
  
}

#' Function that creates layer for each processor
#' 
#' @param term character; term in the formula
#' @param output_dim integer; number of units in the layer
#' @param param_nr integer; identifier for models with more 
#' than one additive predictor
#' @param controls list; control arguments which allow
#' to pass further information
#' @param layer_class a tf or keras layer function
#' @param without_layer function to be used as 
#' layer if \code{controls$with_layer} is FALSE
#' @param name character; name of layer. 
#' if NULL, \code{makelayername} will be used to create layer name
#' @param use_bias logical; use bias in layer. Default is FALSE
#' @param further_layer_args named list; further arguments passed to
#' the layer
#' @param layer_args_names character vector; if NULL, default
#' layer args will be used. Needs to be set for layers that do not
#' provide the arguments of a default Dense layer.
#' @param ... other keras layer parameters
#' 
#' @return a basic processor list structure
#' 
#' @export
#' 
layer_generator <- function(term, output_dim, param_nr, controls, 
                            layer_class = tf$keras$layers$Dense,
                            without_layer = tf$identity,
                            name = makelayername(term, param_nr), 
                            further_layer_args = NULL,
                            layer_args_names = NULL,
                            units = as.integer(output_dim),
                            ...
                            ){
  
  layer_args <- controls$weight_options$general
  
  specific_opt <- term %in% names(controls$weight_options$specific)
  if(specific_opt){
    
    spop <- controls$weight_options$specific[[term]]
    layer_args[names(spop)] <- spop
    
  }
  
  
  warmstart <- term %in% names(controls$weight_options$warmstarts)
  
  if(warmstart)
    layer_args$kernel_initializer <- tf$keras$initializers$Constant(
      controls$weight_options$warmstarts[[term]]
    )
  

  layer_args$units <- units
  layer_args$name <- name

  if(!is.null(further_layer_args)) 
    layer_args <- c(layer_args, further_layer_args)
  if(!is.null(layer_args_names)) 
    layer_args <- layer_args[layer_args_names]
  
  if(controls$with_layer){
    
    layer = function(x){
      return(
        do.call(layer_class, layer_args)(x)
      )
    }
    
  }else{
    
    layer = without_layer
    
  }
  
  return(layer)
  
  
}

int_processor <- function(term, data, output_dim, param_nr, controls){
  
  if(term=="(Intercept)") term <- "1"
  data <- as.data.frame(data[[1]])
  
  layer <- layer_generator(term = term, 
                           output_dim = output_dim, 
                           param_nr = param_nr, 
                           controls = controls)

  list(
    data_trafo = function() matrix(rep(1, nrow(data)), ncol=1),
    predict_trafo = function(newdata){ 
      return(
        matrix(rep(1, nrow(as.data.frame(newdata[[1]]))), ncol=1)
      )
    },
    input_dim = 1L,
    layer = layer,
    coef = function(weights)  as.matrix(weights),
    penalty = NULL
  )
  
  
}

lin_processor <- function(term, data, output_dim, param_nr, controls){
  
  
  layer <- layer_generator(term = term, 
                           output_dim = output_dim, 
                           param_nr = param_nr, 
                           controls = controls)
  
  if(grepl("lin(.*)", term)) term <- paste0(paste(extractvar(term),
                                                  collapse = " + "),
                                            " + 0 ")
  
  list(
    data_trafo = function() model.matrix(object = as.formula(paste0("~ -1 + ", term)), 
                                         data = data),
    predict_trafo = function(newdata){ 
      return(
        model.matrix(object = as.formula(paste0("~ -1 + ", term)),
                     data = as.data.frame(newdata))
      )
    },
    input_dim = as.integer(ncol(model.matrix(object = as.formula(paste0("~ -1 +", term)), 
                                  data = data))),
    layer = layer,
    coef = function(weights)  as.matrix(weights),
    penalty = NULL
  )
  
}

gam_processor <- function(term, data, output_dim, param_nr, controls){
  
  output_dim <- as.integer(output_dim)
  # extract mgcv smooth object
  evaluated_gam_term <- handle_gam_term(object = term, 
                                        data = data, 
                                        controls = controls)
  # get sp and S
  sp_and_S <- extract_sp_S(evaluated_gam_term)
  # extract Xs
  if(length(evaluated_gam_term)==1){
    thisX <- evaluated_gam_term[[1]]$X
  }else{
    thisX <- do.call("cbind", lapply(evaluated_gam_term, "[[", "X"))
  }
  # get default Z matrix, which is possibly overwritten afterwards
  Z <- diag(rep(1,ncol(thisX)))
  # constraint
  if(controls$zero_constraint_for_smooths & 
     length(evaluated_gam_term)==1 & 
     !evaluated_gam_term[[1]]$dim>1){
    Z <- orthog_structured_smooths_Z(
      evaluated_gam_term[[1]]$X,
      matrix(rep(1,NROW(evaluated_gam_term[[1]]$X)), ncol=1)
    )
    sp_and_S[[2]][[1]] <- orthog_P(sp_and_S[[2]][[1]],Z)
  }else if(evaluated_gam_term[[1]]$dim>1 & 
           length(evaluated_gam_term)==1){
    # tensor product -> merge and keep dummy
    sp_and_S <- list(sp = 1, 
                     S = list(do.call("+", lapply(1:length(sp_and_S[[2]]), function(i)
                       sp_and_S[[1]][[1]][i] * sp_and_S[[2]][[i]]))))
  }
  P <- as.matrix(bdiag(lapply(1:length(sp_and_S[[1]]), function(i) 
    controls$sp_scale(data) * sp_and_S[[1]][[i]] * sp_and_S[[2]][[i]])))
  
  layer <- layer_generator(term = term, 
                           output_dim = output_dim, 
                           param_nr = param_nr, 
                           controls = controls,
                           further_layer_args = list(P = P),
                           layer_args_names = c("name", "units", "P", "trainable", 
                                                "kernel_initializer"),
                           layer_class = layer_spline
                           )

  list(
    data_trafo = function() thisX %*% Z,
    predict_trafo = function(newdata) predict_gam_handler(evaluated_gam_term, newdata = newdata) %*% Z,
    input_dim = as.integer(ncol(thisX %*% Z)),
    layer = layer,
    coef = function(weights)  as.matrix(weights),
    partial_effect = function(weights, newdata=NULL){
      if(is.null(newdata))
        return(thisX %*% Z %*% weights)
      return(predict_gam_handler(evaluated_gam_term, newdata = newdata) %*% Z %*% weights)
    },
    plot_fun = function(self, weights, grid_length) gam_plot_data(self, weights, grid_length),
    get_org_values = function() data[extractvar(term)],
    penalty = list(type = "spline", values = P, dim = output_dim)
  )
}


l1_processor <- function(term, data, output_dim, param_nr, controls){
  # l1 (Tib)
  lambda = controls$sp_scale(data) * extractval(term, "la")
  
  layer <- layer_generator(term = term, 
                           output_dim = output_dim, 
                           param_nr = param_nr, 
                           controls = controls,
                           further_layer_args = list(la = lambda),
                           layer_args_names = c("name", "units", "la"),
                           layer_class = tib_layer,
                           without_layer = function(x, ...) 
                             return(simplyconnected_layer(
                               la = lambda,
                               name = makelayername(term, param_nr),
                               ...
                             )(x))
  )

  penalty <- if(output_dim > 1){
    list(type = "inverse_group", values = lambda, dim = output_dim)
  }else{
    list(type = "l1", values = lambda, dim = output_dim)
  }
  
  list(
    data_trafo = function() data[extractvar(term)],
    predict_trafo = function(newdata) newdata[extractvar(term)],
    input_dim = as.integer(extractlen(term, data)),
    layer = layer,
    coef = function(weights){ 
      weights <- lapply(weights, as.matrix)
      return(
        weights[[1]] * matrix(rep(weights[[2]], each=ncol(weights[[1]])), 
                              ncol=ncol(weights[[1]]), byrow = TRUE)
      )
    },
    penalty = penalty
  )
  
}

l2_processor <- function(term, data, output_dim, param_nr, controls){
  # ridge
  
  lambda = controls$sp_scale(data) * extractval(term, "la")
  
  layer <- layer_generator(term = term, 
                           output_dim = output_dim, 
                           param_nr = param_nr, 
                           controls = controls,
                           kernel_regularizer = tf$keras$regularizers$l2(l = lambda)
  )

  list(
    data_trafo = function() data[extractvar(term)],
    predict_trafo = function(newdata) newdata[extractvar(term)],
    input_dim = as.integer(extractlen(term, data)),
    layer = layer,
    coef = function(weights)  as.matrix(weights),
    penalty = list(type = "l2", values = lambda, dim = output_dim)
  )
  
}

offset_processor <- function(term, data, output_dim, param_nr, controls=NULL){
  
  layer <- layer_generator(term = term, 
                           output_dim = output_dim, 
                           param_nr = param_nr, 
                           controls = controls,
                           trainable = FALSE,
                           kernel_initializer = tf$keras$initializers$Ones,
                           )
  
  list(
    data_trafo = function() data[extractvar(term)],
    predict_trafo = function(newdata) newdata[extractvar(term)],
    input_dim = as.integer(extractlen(term, data)),
    layer = layer
  )
}

rwt_processor <- function(term, data, output_dim, param_nr, controls){
  
  special_layer <- suppressWarnings(extractval(term, "layer"))
  if(!is.null(special_layer)) special_layer <- as.character(special_layer)
  term <- remove_layer(term)
  
  terms <- get_terms_rwt(term)
  
  terms <- lapply(terms, function(t){ 
    args <- list(term = t, data = data, output_dim = output_dim,
                 param_nr = param_nr, controls = controls)
    args$controls$with_layer <- FALSE
    spec <- get_special(t, specials = names(controls$procs))
    if(is.null(spec)){
      if(t=="1")
        return(do.call(int_processor, args)) else
          return(do.call(lin_processor, args))
    }
    do.call(controls$procs[[spec]], args)
  })
  
  dims <- sapply(terms, "[[", "input_dim")
  penalties <- lapply(terms, "[[", "penalty")
  combined_penalty <- combine_penalties(penalties, dims)
  
  if(is.null(special_layer)){ 
    
    this_layer <- function(...)
      tf$keras$layers$Dense(units = output_dim,
                            trainable = TRUE,
                            use_bias = FALSE,
                            kernel_regularizer = combined_penalty,
                            name = makelayername(term, param_nr),
                            ...) 
    
  }else{
    
    # special_layer <- special_layer[!sapply(special_layer, is.null)]
    # if(length(special_layer)==2) 
      # stop("In an RWT, only a single term can have a special layer.")
    
    this_layer <- function(...){
      
      args <- c(list(
        units = output_dim,
        kernel_regularizer = combined_penalty,
        name = makelayername(term, param_nr),
        ...
      ), controls$special_layer_args)
      
      do.call(special_layer, args)
      
    }
    
  }
  
  if(controls$with_layer){
    layer = function(x, ...){
      a <- tf_stride_cols(x, 1L, as.integer(dims[1]))
      b <- tf_stride_cols(x, 1L + as.integer(dims[1]), as.integer(sum(dims)))
      rwt <- tf_row_tensor(a,b)
      return(this_layer(...)(rwt))
    }
  }else{
    layer = tf$identity
  }
  
  list(
    data_trafo = function() do.call("cbind", lapply(terms, function(x) x$data_trafo())),
    predict_trafo = function(newdata) 
      do.call("cbind", lapply(terms, function(x) x$predict_trafo(newdata))),
    input_dim = sum(dims),
    layer = layer,
    coef = function(weights) lapply(terms, function(x) x$coef(weights)),
    partial_effect = function(...) lapply(terms, function(x) x$partial_effect(...)),
    plot_fun = function(...) lapply(terms, function(x) x$plot_fun(...)),
    get_org_values = function() do.call("cbind", lapply(terms, function(x) x$get_org_values())),
    penalty = penalties
  )
  
}

dnn_processor <- function(dnn){
  
  if(is.list(dnn) & length(dnn)==2){
    do.call("dnn_image_placeholder_processor", dnn)
  }else{
    dnn_placeholder_processor(dnn)
  }
}

dnn_placeholder_processor <- function(dnn){
  function(term, data, output_dim, param_nr, controls=NULL){
    list(
      data_trafo = function() data[extractvar(term)],
      predict_trafo = function(newdata) newdata[extractvar(term)],
      input_dim = as.integer(extractlen(term, data)),
      layer = dnn
    )
  }
}

dnn_image_placeholder_processor <- function(dnn, size){
  function(term, data, output_dim, param_nr, controls=NULL){
    list(
      data_trafo = function() as.data.frame(data[extractvar(term)]),
      predict_trafo = function(newdata) as.data.frame(newdata[extractvar(term)]),
      input_dim = as.integer(size),
      layer = dnn
    )
  }
}

